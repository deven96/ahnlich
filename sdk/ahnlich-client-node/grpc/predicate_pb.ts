// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file predicate.proto (package predicates, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { MetadataValue } from "./metadata_pb.js";

/**
 * @generated from message predicates.Predicate
 */
export class Predicate extends Message<Predicate> {
  /**
   * @generated from oneof predicates.Predicate.kind
   */
  kind:
    | {
        /**
         * @generated from field: predicates.Equals equals = 1;
         */
        value: Equals;
        case: "equals";
      }
    | {
        /**
         * @generated from field: predicates.NotEquals not_equals = 2;
         */
        value: NotEquals;
        case: "notEquals";
      }
    | {
        /**
         * @generated from field: predicates.In in = 3;
         */
        value: In;
        case: "in";
      }
    | {
        /**
         * @generated from field: predicates.NotIn not_in = 4;
         */
        value: NotIn;
        case: "notIn";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Predicate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "predicates.Predicate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "equals", kind: "message", T: Equals, oneof: "kind" },
    { no: 2, name: "not_equals", kind: "message", T: NotEquals, oneof: "kind" },
    { no: 3, name: "in", kind: "message", T: In, oneof: "kind" },
    { no: 4, name: "not_in", kind: "message", T: NotIn, oneof: "kind" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Predicate {
    return new Predicate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Predicate {
    return new Predicate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Predicate {
    return new Predicate().fromJsonString(jsonString, options);
  }

  static equals(
    a: Predicate | PlainMessage<Predicate> | undefined,
    b: Predicate | PlainMessage<Predicate> | undefined,
  ): boolean {
    return proto3.util.equals(Predicate, a, b);
  }
}

/**
 * @generated from message predicates.Equals
 */
export class Equals extends Message<Equals> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: metadata.MetadataValue value = 2;
   */
  value?: MetadataValue;

  constructor(data?: PartialMessage<Equals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "predicates.Equals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: MetadataValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Equals {
    return new Equals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Equals {
    return new Equals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Equals {
    return new Equals().fromJsonString(jsonString, options);
  }

  static equals(
    a: Equals | PlainMessage<Equals> | undefined,
    b: Equals | PlainMessage<Equals> | undefined,
  ): boolean {
    return proto3.util.equals(Equals, a, b);
  }
}

/**
 * @generated from message predicates.NotEquals
 */
export class NotEquals extends Message<NotEquals> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: metadata.MetadataValue value = 2;
   */
  value?: MetadataValue;

  constructor(data?: PartialMessage<NotEquals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "predicates.NotEquals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: MetadataValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotEquals {
    return new NotEquals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotEquals {
    return new NotEquals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotEquals {
    return new NotEquals().fromJsonString(jsonString, options);
  }

  static equals(
    a: NotEquals | PlainMessage<NotEquals> | undefined,
    b: NotEquals | PlainMessage<NotEquals> | undefined,
  ): boolean {
    return proto3.util.equals(NotEquals, a, b);
  }
}

/**
 * @generated from message predicates.In
 */
export class In extends Message<In> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: repeated metadata.MetadataValue values = 2;
   */
  values: MetadataValue[] = [];

  constructor(data?: PartialMessage<In>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "predicates.In";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "values", kind: "message", T: MetadataValue, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): In {
    return new In().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): In {
    return new In().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): In {
    return new In().fromJsonString(jsonString, options);
  }

  static equals(
    a: In | PlainMessage<In> | undefined,
    b: In | PlainMessage<In> | undefined,
  ): boolean {
    return proto3.util.equals(In, a, b);
  }
}

/**
 * @generated from message predicates.NotIn
 */
export class NotIn extends Message<NotIn> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: repeated metadata.MetadataValue values = 2;
   */
  values: MetadataValue[] = [];

  constructor(data?: PartialMessage<NotIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "predicates.NotIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "values", kind: "message", T: MetadataValue, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotIn {
    return new NotIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotIn {
    return new NotIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotIn {
    return new NotIn().fromJsonString(jsonString, options);
  }

  static equals(
    a: NotIn | PlainMessage<NotIn> | undefined,
    b: NotIn | PlainMessage<NotIn> | undefined,
  ): boolean {
    return proto3.util.equals(NotIn, a, b);
  }
}

/**
 * @generated from message predicates.PredicateCondition
 */
export class PredicateCondition extends Message<PredicateCondition> {
  /**
   * @generated from oneof predicates.PredicateCondition.kind
   */
  kind:
    | {
        /**
         * @generated from field: predicates.Predicate value = 1;
         */
        value: Predicate;
        case: "value";
      }
    | {
        /**
         * @generated from field: predicates.AndCondition and = 2;
         */
        value: AndCondition;
        case: "and";
      }
    | {
        /**
         * @generated from field: predicates.OrCondition or = 3;
         */
        value: OrCondition;
        case: "or";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PredicateCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "predicates.PredicateCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "message", T: Predicate, oneof: "kind" },
    { no: 2, name: "and", kind: "message", T: AndCondition, oneof: "kind" },
    { no: 3, name: "or", kind: "message", T: OrCondition, oneof: "kind" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PredicateCondition {
    return new PredicateCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PredicateCondition {
    return new PredicateCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): PredicateCondition {
    return new PredicateCondition().fromJsonString(jsonString, options);
  }

  static equals(
    a: PredicateCondition | PlainMessage<PredicateCondition> | undefined,
    b: PredicateCondition | PlainMessage<PredicateCondition> | undefined,
  ): boolean {
    return proto3.util.equals(PredicateCondition, a, b);
  }
}

/**
 * @generated from message predicates.AndCondition
 */
export class AndCondition extends Message<AndCondition> {
  /**
   * @generated from field: predicates.PredicateCondition left = 1;
   */
  left?: PredicateCondition;

  /**
   * @generated from field: predicates.PredicateCondition right = 2;
   */
  right?: PredicateCondition;

  constructor(data?: PartialMessage<AndCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "predicates.AndCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "left", kind: "message", T: PredicateCondition },
    { no: 2, name: "right", kind: "message", T: PredicateCondition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AndCondition {
    return new AndCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AndCondition {
    return new AndCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AndCondition {
    return new AndCondition().fromJsonString(jsonString, options);
  }

  static equals(
    a: AndCondition | PlainMessage<AndCondition> | undefined,
    b: AndCondition | PlainMessage<AndCondition> | undefined,
  ): boolean {
    return proto3.util.equals(AndCondition, a, b);
  }
}

/**
 * @generated from message predicates.OrCondition
 */
export class OrCondition extends Message<OrCondition> {
  /**
   * @generated from field: predicates.PredicateCondition left = 1;
   */
  left?: PredicateCondition;

  /**
   * @generated from field: predicates.PredicateCondition right = 2;
   */
  right?: PredicateCondition;

  constructor(data?: PartialMessage<OrCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "predicates.OrCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "left", kind: "message", T: PredicateCondition },
    { no: 2, name: "right", kind: "message", T: PredicateCondition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrCondition {
    return new OrCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrCondition {
    return new OrCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrCondition {
    return new OrCondition().fromJsonString(jsonString, options);
  }

  static equals(
    a: OrCondition | PlainMessage<OrCondition> | undefined,
    b: OrCondition | PlainMessage<OrCondition> | undefined,
  ): boolean {
    return proto3.util.equals(OrCondition, a, b);
  }
}
