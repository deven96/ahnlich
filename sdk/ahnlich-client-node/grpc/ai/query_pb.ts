// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file ai/query.proto (package ai.query, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { AIModel } from "./models_pb.js";
import { NonLinearAlgorithm, NonLinearIndex } from "../algorithm/nonlinear_pb.js";
import { PredicateCondition } from "../predicate_pb.js";
import { AiStoreEntry, StoreInput } from "../keyval_pb.js";
import { Algorithm } from "../algorithm/algorithm_pb.js";
import { PreprocessAction } from "./preprocess_pb.js";
import { ExecutionProvider } from "./execution_provider_pb.js";

/**
 * @generated from message ai.query.CreateStore
 */
export class CreateStore extends Message<CreateStore> {
  /**
   * Creates a new store with the following details:
   * - store name
   * - AI query and index models (String or Images are currently supported. It's worth noting that queries/insertions must match the model's supported type)
   * - list of predicates for indexing
   * - optional non-linear algorithm indices for advanced searching
   * - store behavior settings, like error handling and storing original data
   *
   * Unique name for the store
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * AI model used for querying (string or image-based)
   *
   * @generated from field: ai.models.AIModel query_model = 2;
   */
  queryModel = AIModel.ALL_MINI_LM_L6_V2;

  /**
   * AI model used for indexing
   *
   * @generated from field: ai.models.AIModel index_model = 3;
   */
  indexModel = AIModel.ALL_MINI_LM_L6_V2;

  /**
   * List of predicates used for creating indices
   *
   * @generated from field: repeated string predicates = 4;
   */
  predicates: string[] = [];

  /**
   * Optional non-linear indices
   *
   * @generated from field: repeated algorithm.nonlinear.NonLinearIndex non_linear_indices = 5;
   */
  nonLinearIndices: NonLinearIndex[] = [];

  /**
   * Whether to throw an error if the store already exists
   *
   * @generated from field: bool error_if_exists = 6;
   */
  errorIfExists = false;

  /**
   * Flag to store original data. Used if you wanna keep the original(image or text) input sent
   *
   * @generated from field: bool store_original = 7;
   */
  storeOriginal = false;

  constructor(data?: PartialMessage<CreateStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.CreateStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "query_model", kind: "enum", T: proto3.getEnumType(AIModel) },
    { no: 3, name: "index_model", kind: "enum", T: proto3.getEnumType(AIModel) },
    { no: 4, name: "predicates", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "non_linear_indices", kind: "message", T: NonLinearIndex, repeated: true },
    { no: 6, name: "error_if_exists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "store_original", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateStore {
    return new CreateStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateStore {
    return new CreateStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateStore {
    return new CreateStore().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateStore | PlainMessage<CreateStore> | undefined,
    b: CreateStore | PlainMessage<CreateStore> | undefined,
  ): boolean {
    return proto3.util.equals(CreateStore, a, b);
  }
}

/**
 * @generated from message ai.query.GetPred
 */
export class GetPred extends Message<GetPred> {
  /**
   * Fetches values from the store that match the specified predicates
   * Validation checks if the predicates are enabled
   *
   * Name of the store
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * Condition to match for predicates
   *
   * @generated from field: predicates.PredicateCondition condition = 2;
   */
  condition?: PredicateCondition;

  constructor(data?: PartialMessage<GetPred>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.GetPred";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "condition", kind: "message", T: PredicateCondition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPred {
    return new GetPred().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPred {
    return new GetPred().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPred {
    return new GetPred().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetPred | PlainMessage<GetPred> | undefined,
    b: GetPred | PlainMessage<GetPred> | undefined,
  ): boolean {
    return proto3.util.equals(GetPred, a, b);
  }
}

/**
 * @generated from message ai.query.GetSimN
 */
export class GetSimN extends Message<GetSimN> {
  /**
   * Retrieves the top N similar entries from the store based on a given search input and algorithm
   *
   * Name of the store
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * Input data to search (can be a string or image)
   *
   * @generated from field: keyval.StoreInput search_input = 2;
   */
  searchInput?: StoreInput;

  /**
   * Optional: filters results by predicate condition
   *
   * @generated from field: optional predicates.PredicateCondition condition = 3;
   */
  condition?: PredicateCondition;

  /**
   * Number of similar results to return
   *
   * @generated from field: uint64 closest_n = 4;
   */
  closestN = protoInt64.zero;

  /**
   * Algorithm to use for similarity search
   *
   * @generated from field: algorithm.algorithms.Algorithm algorithm = 5;
   */
  algorithm = Algorithm.EuclideanDistance;

  /**
   * Preprocessing actions to apply to input before querying
   *
   * @generated from field: ai.preprocess.PreprocessAction preprocess_action = 6;
   */
  preprocessAction = PreprocessAction.NoPreprocessing;

  /**
   * Optional execution provider for specific optimizations
   *
   * @generated from field: optional ai.execution_provider.ExecutionProvider execution_provider = 7;
   */
  executionProvider?: ExecutionProvider;

  /**
   * Optional runtime parameters for the model (e.g., confidence_threshold for face detection)
   *
   * @generated from field: map<string, string> model_params = 8;
   */
  modelParams: { [key: string]: string } = {};

  constructor(data?: PartialMessage<GetSimN>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.GetSimN";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "search_input", kind: "message", T: StoreInput },
    { no: 3, name: "condition", kind: "message", T: PredicateCondition, opt: true },
    { no: 4, name: "closest_n", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "algorithm", kind: "enum", T: proto3.getEnumType(Algorithm) },
    { no: 6, name: "preprocess_action", kind: "enum", T: proto3.getEnumType(PreprocessAction) },
    {
      no: 7,
      name: "execution_provider",
      kind: "enum",
      T: proto3.getEnumType(ExecutionProvider),
      opt: true,
    },
    {
      no: 8,
      name: "model_params",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSimN {
    return new GetSimN().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSimN {
    return new GetSimN().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSimN {
    return new GetSimN().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetSimN | PlainMessage<GetSimN> | undefined,
    b: GetSimN | PlainMessage<GetSimN> | undefined,
  ): boolean {
    return proto3.util.equals(GetSimN, a, b);
  }
}

/**
 * @generated from message ai.query.CreatePredIndex
 */
export class CreatePredIndex extends Message<CreatePredIndex> {
  /**
   * Creates predicate indexes for a store. Adds new predicates if they don’t already exist
   *
   * Store name
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * Predicates to use for indexing
   *
   * @generated from field: repeated string predicates = 2;
   */
  predicates: string[] = [];

  constructor(data?: PartialMessage<CreatePredIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.CreatePredIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "predicates", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreatePredIndex {
    return new CreatePredIndex().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreatePredIndex {
    return new CreatePredIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreatePredIndex {
    return new CreatePredIndex().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreatePredIndex | PlainMessage<CreatePredIndex> | undefined,
    b: CreatePredIndex | PlainMessage<CreatePredIndex> | undefined,
  ): boolean {
    return proto3.util.equals(CreatePredIndex, a, b);
  }
}

/**
 * @generated from message ai.query.CreateNonLinearAlgorithmIndex
 */
export class CreateNonLinearAlgorithmIndex extends Message<CreateNonLinearAlgorithmIndex> {
  /**
   * Creates non-linear algorithm indices for the store if they don't already exist
   *
   * Store name
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * Non-linear indices to create
   *
   * @generated from field: repeated algorithm.nonlinear.NonLinearIndex non_linear_indices = 2;
   */
  nonLinearIndices: NonLinearIndex[] = [];

  constructor(data?: PartialMessage<CreateNonLinearAlgorithmIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.CreateNonLinearAlgorithmIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "non_linear_indices", kind: "message", T: NonLinearIndex, repeated: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): CreateNonLinearAlgorithmIndex {
    return new CreateNonLinearAlgorithmIndex().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): CreateNonLinearAlgorithmIndex {
    return new CreateNonLinearAlgorithmIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): CreateNonLinearAlgorithmIndex {
    return new CreateNonLinearAlgorithmIndex().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateNonLinearAlgorithmIndex | PlainMessage<CreateNonLinearAlgorithmIndex> | undefined,
    b: CreateNonLinearAlgorithmIndex | PlainMessage<CreateNonLinearAlgorithmIndex> | undefined,
  ): boolean {
    return proto3.util.equals(CreateNonLinearAlgorithmIndex, a, b);
  }
}

/**
 * @generated from message ai.query.DropPredIndex
 */
export class DropPredIndex extends Message<DropPredIndex> {
  /**
   * Drops a predicate index for the store
   * Throws an error if the predicate index doesn’t exist (controlled by `error_if_not_exists`)
   *
   * Store name
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * Predicates to remove
   *
   * @generated from field: repeated string predicates = 2;
   */
  predicates: string[] = [];

  /**
   * Flag to enforce error if the predicate doesn’t exist
   *
   * @generated from field: bool error_if_not_exists = 3;
   */
  errorIfNotExists = false;

  constructor(data?: PartialMessage<DropPredIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.DropPredIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "predicates", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "error_if_not_exists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DropPredIndex {
    return new DropPredIndex().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DropPredIndex {
    return new DropPredIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DropPredIndex {
    return new DropPredIndex().fromJsonString(jsonString, options);
  }

  static equals(
    a: DropPredIndex | PlainMessage<DropPredIndex> | undefined,
    b: DropPredIndex | PlainMessage<DropPredIndex> | undefined,
  ): boolean {
    return proto3.util.equals(DropPredIndex, a, b);
  }
}

/**
 * @generated from message ai.query.DropNonLinearAlgorithmIndex
 */
export class DropNonLinearAlgorithmIndex extends Message<DropNonLinearAlgorithmIndex> {
  /**
   * Drops non-linear algorithm indices from the store
   * Similar to dropping predicate indices, does not remove existing data
   *
   * Store name
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * Non-linear indices to remove
   *
   * @generated from field: repeated algorithm.nonlinear.NonLinearAlgorithm non_linear_indices = 2;
   */
  nonLinearIndices: NonLinearAlgorithm[] = [];

  /**
   * Flag to enforce error if the index doesn’t exist
   *
   * @generated from field: bool error_if_not_exists = 3;
   */
  errorIfNotExists = false;

  constructor(data?: PartialMessage<DropNonLinearAlgorithmIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.DropNonLinearAlgorithmIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 2,
      name: "non_linear_indices",
      kind: "enum",
      T: proto3.getEnumType(NonLinearAlgorithm),
      repeated: true,
    },
    { no: 3, name: "error_if_not_exists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): DropNonLinearAlgorithmIndex {
    return new DropNonLinearAlgorithmIndex().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): DropNonLinearAlgorithmIndex {
    return new DropNonLinearAlgorithmIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): DropNonLinearAlgorithmIndex {
    return new DropNonLinearAlgorithmIndex().fromJsonString(jsonString, options);
  }

  static equals(
    a: DropNonLinearAlgorithmIndex | PlainMessage<DropNonLinearAlgorithmIndex> | undefined,
    b: DropNonLinearAlgorithmIndex | PlainMessage<DropNonLinearAlgorithmIndex> | undefined,
  ): boolean {
    return proto3.util.equals(DropNonLinearAlgorithmIndex, a, b);
  }
}

/**
 * @generated from message ai.query.DelKey
 */
export class DelKey extends Message<DelKey> {
  /**
   * Deletes a key-value pair from the store, matching the given key
   * Updates indices non-blocking after deletion
   *
   * Store name
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * Key to delete (type depends on the store model)
   *
   * @generated from field: repeated keyval.StoreInput keys = 2;
   */
  keys: StoreInput[] = [];

  constructor(data?: PartialMessage<DelKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.DelKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "keys", kind: "message", T: StoreInput, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DelKey {
    return new DelKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DelKey {
    return new DelKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DelKey {
    return new DelKey().fromJsonString(jsonString, options);
  }

  static equals(
    a: DelKey | PlainMessage<DelKey> | undefined,
    b: DelKey | PlainMessage<DelKey> | undefined,
  ): boolean {
    return proto3.util.equals(DelKey, a, b);
  }
}

/**
 * @generated from message ai.query.DelPred
 */
export class DelPred extends Message<DelPred> {
  /**
   * Deletes values from the store based on the provided predicate condition
   * This is a passthrough to the underlying DB service
   * Updates indices non-blocking after deletion
   *
   * Store name
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * The condition for the predicate deletion
   *
   * @generated from field: predicates.PredicateCondition condition = 2;
   */
  condition?: PredicateCondition;

  constructor(data?: PartialMessage<DelPred>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.DelPred";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "condition", kind: "message", T: PredicateCondition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DelPred {
    return new DelPred().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DelPred {
    return new DelPred().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DelPred {
    return new DelPred().fromJsonString(jsonString, options);
  }

  static equals(
    a: DelPred | PlainMessage<DelPred> | undefined,
    b: DelPred | PlainMessage<DelPred> | undefined,
  ): boolean {
    return proto3.util.equals(DelPred, a, b);
  }
}

/**
 * @generated from message ai.query.DropStore
 */
export class DropStore extends Message<DropStore> {
  /**
   * Deletes the entire store and removes all associated data
   * Destroys the store, and updates indices accordingly
   *
   * Store name
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * Flag to throw an error if the store does not exist
   *
   * @generated from field: bool error_if_not_exists = 2;
   */
  errorIfNotExists = false;

  constructor(data?: PartialMessage<DropStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.DropStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "error_if_not_exists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DropStore {
    return new DropStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DropStore {
    return new DropStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DropStore {
    return new DropStore().fromJsonString(jsonString, options);
  }

  static equals(
    a: DropStore | PlainMessage<DropStore> | undefined,
    b: DropStore | PlainMessage<DropStore> | undefined,
  ): boolean {
    return proto3.util.equals(DropStore, a, b);
  }
}

/**
 * @generated from message ai.query.GetKey
 */
export class GetKey extends Message<GetKey> {
  /**
   * Fetches specific input(image or string) from a store. This only works if, store_original is set to true
   *
   * Store name
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * Keys to retrieve from the store
   *
   * @generated from field: repeated keyval.StoreInput keys = 2;
   */
  keys: StoreInput[] = [];

  constructor(data?: PartialMessage<GetKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.GetKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "keys", kind: "message", T: StoreInput, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKey {
    return new GetKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKey {
    return new GetKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKey {
    return new GetKey().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetKey | PlainMessage<GetKey> | undefined,
    b: GetKey | PlainMessage<GetKey> | undefined,
  ): boolean {
    return proto3.util.equals(GetKey, a, b);
  }
}

/**
 * Returns the information about the server, including version, host, and port
 *
 * @generated from message ai.query.InfoServer
 */
export class InfoServer extends Message<InfoServer> {
  constructor(data?: PartialMessage<InfoServer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.InfoServer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InfoServer {
    return new InfoServer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InfoServer {
    return new InfoServer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InfoServer {
    return new InfoServer().fromJsonString(jsonString, options);
  }

  static equals(
    a: InfoServer | PlainMessage<InfoServer> | undefined,
    b: InfoServer | PlainMessage<InfoServer> | undefined,
  ): boolean {
    return proto3.util.equals(InfoServer, a, b);
  }
}

/**
 * Lists all clients currently connected to the server
 *
 * @generated from message ai.query.ListClients
 */
export class ListClients extends Message<ListClients> {
  constructor(data?: PartialMessage<ListClients>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.ListClients";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClients {
    return new ListClients().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClients {
    return new ListClients().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClients {
    return new ListClients().fromJsonString(jsonString, options);
  }

  static equals(
    a: ListClients | PlainMessage<ListClients> | undefined,
    b: ListClients | PlainMessage<ListClients> | undefined,
  ): boolean {
    return proto3.util.equals(ListClients, a, b);
  }
}

/**
 * Lists all stores on the server along with details like store size, embedding dimensions, AI models, etc.
 *
 * @generated from message ai.query.ListStores
 */
export class ListStores extends Message<ListStores> {
  constructor(data?: PartialMessage<ListStores>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.ListStores";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListStores {
    return new ListStores().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListStores {
    return new ListStores().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListStores {
    return new ListStores().fromJsonString(jsonString, options);
  }

  static equals(
    a: ListStores | PlainMessage<ListStores> | undefined,
    b: ListStores | PlainMessage<ListStores> | undefined,
  ): boolean {
    return proto3.util.equals(ListStores, a, b);
  }
}

/**
 * @generated from message ai.query.GetStore
 */
export class GetStore extends Message<GetStore> {
  /**
   * Gets detailed information about a specific store by name. Returns an error if the store does not exist.
   *
   * Store name
   *
   * @generated from field: string store = 1;
   */
  store = "";

  constructor(data?: PartialMessage<GetStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.GetStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStore {
    return new GetStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStore {
    return new GetStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStore {
    return new GetStore().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetStore | PlainMessage<GetStore> | undefined,
    b: GetStore | PlainMessage<GetStore> | undefined,
  ): boolean {
    return proto3.util.equals(GetStore, a, b);
  }
}

/**
 * Purges (deletes) all stores on the server, effectively destroying all stored data
 *
 * @generated from message ai.query.PurgeStores
 */
export class PurgeStores extends Message<PurgeStores> {
  constructor(data?: PartialMessage<PurgeStores>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.PurgeStores";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PurgeStores {
    return new PurgeStores().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PurgeStores {
    return new PurgeStores().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PurgeStores {
    return new PurgeStores().fromJsonString(jsonString, options);
  }

  static equals(
    a: PurgeStores | PlainMessage<PurgeStores> | undefined,
    b: PurgeStores | PlainMessage<PurgeStores> | undefined,
  ): boolean {
    return proto3.util.equals(PurgeStores, a, b);
  }
}

/**
 * Pings the server to check if it's reachable (typically for health-checking)
 *
 * @generated from message ai.query.Ping
 */
export class Ping extends Message<Ping> {
  constructor(data?: PartialMessage<Ping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.Ping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ping {
    return new Ping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ping {
    return new Ping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ping {
    return new Ping().fromJsonString(jsonString, options);
  }

  static equals(
    a: Ping | PlainMessage<Ping> | undefined,
    b: Ping | PlainMessage<Ping> | undefined,
  ): boolean {
    return proto3.util.equals(Ping, a, b);
  }
}

/**
 * @generated from message ai.query.Set
 */
export class Set extends Message<Set> {
  /**
   * Sets a list of entries in the store
   * Each entry corresponds to a key-value pair and is validated before insertion
   *
   * Store name
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * List of entries to set
   *
   * @generated from field: repeated keyval.AiStoreEntry inputs = 2;
   */
  inputs: AiStoreEntry[] = [];

  /**
   * Preprocessing action to apply to inputs before setting
   *
   * @generated from field: ai.preprocess.PreprocessAction preprocess_action = 3;
   */
  preprocessAction = PreprocessAction.NoPreprocessing;

  /**
   * Optional execution provider for optimizations
   *
   * @generated from field: optional ai.execution_provider.ExecutionProvider execution_provider = 4;
   */
  executionProvider?: ExecutionProvider;

  /**
   * Optional runtime parameters for the model (e.g., confidence_threshold for face detection)
   *
   * @generated from field: map<string, string> model_params = 5;
   */
  modelParams: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Set>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.Set";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "inputs", kind: "message", T: AiStoreEntry, repeated: true },
    { no: 3, name: "preprocess_action", kind: "enum", T: proto3.getEnumType(PreprocessAction) },
    {
      no: 4,
      name: "execution_provider",
      kind: "enum",
      T: proto3.getEnumType(ExecutionProvider),
      opt: true,
    },
    {
      no: 5,
      name: "model_params",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Set {
    return new Set().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Set {
    return new Set().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Set {
    return new Set().fromJsonString(jsonString, options);
  }

  static equals(
    a: Set | PlainMessage<Set> | undefined,
    b: Set | PlainMessage<Set> | undefined,
  ): boolean {
    return proto3.util.equals(Set, a, b);
  }
}

/**
 * @generated from message ai.query.ConvertStoreInputToEmbeddings
 */
export class ConvertStoreInputToEmbeddings extends Message<ConvertStoreInputToEmbeddings> {
  /**
   * Convert store inputs to embeddings
   *
   * Input keys to retrieve from the store
   *
   * @generated from field: repeated keyval.StoreInput store_inputs = 1;
   */
  storeInputs: StoreInput[] = [];

  /**
   * Preprocessing actions to apply to input before querying
   *
   * @generated from field: optional ai.preprocess.PreprocessAction preprocess_action = 2;
   */
  preprocessAction?: PreprocessAction;

  /**
   * AI model used for querying (string or image-based)
   *
   * @generated from field: ai.models.AIModel model = 3;
   */
  model = AIModel.ALL_MINI_LM_L6_V2;

  /**
   * Optional runtime parameters for the model (e.g., confidence_threshold for face detection)
   *
   * @generated from field: map<string, string> model_params = 4;
   */
  modelParams: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ConvertStoreInputToEmbeddings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ai.query.ConvertStoreInputToEmbeddings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store_inputs", kind: "message", T: StoreInput, repeated: true },
    {
      no: 2,
      name: "preprocess_action",
      kind: "enum",
      T: proto3.getEnumType(PreprocessAction),
      opt: true,
    },
    { no: 3, name: "model", kind: "enum", T: proto3.getEnumType(AIModel) },
    {
      no: 4,
      name: "model_params",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): ConvertStoreInputToEmbeddings {
    return new ConvertStoreInputToEmbeddings().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): ConvertStoreInputToEmbeddings {
    return new ConvertStoreInputToEmbeddings().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ConvertStoreInputToEmbeddings {
    return new ConvertStoreInputToEmbeddings().fromJsonString(jsonString, options);
  }

  static equals(
    a: ConvertStoreInputToEmbeddings | PlainMessage<ConvertStoreInputToEmbeddings> | undefined,
    b: ConvertStoreInputToEmbeddings | PlainMessage<ConvertStoreInputToEmbeddings> | undefined,
  ): boolean {
    return proto3.util.equals(ConvertStoreInputToEmbeddings, a, b);
  }
}
