// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file keyval.proto (package keyval, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { MetadataValue } from "./metadata_pb.js";

/**
 * @generated from message keyval.StoreName
 */
export class StoreName extends Message<StoreName> {
  /**
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<StoreName>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "keyval.StoreName";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreName {
    return new StoreName().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreName {
    return new StoreName().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreName {
    return new StoreName().fromJsonString(jsonString, options);
  }

  static equals(
    a: StoreName | PlainMessage<StoreName> | undefined,
    b: StoreName | PlainMessage<StoreName> | undefined,
  ): boolean {
    return proto3.util.equals(StoreName, a, b);
  }
}

/**
 * @generated from message keyval.StoreKey
 */
export class StoreKey extends Message<StoreKey> {
  /**
   * @generated from field: repeated float key = 1;
   */
  key: number[] = [];

  constructor(data?: PartialMessage<StoreKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "keyval.StoreKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreKey {
    return new StoreKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreKey {
    return new StoreKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreKey {
    return new StoreKey().fromJsonString(jsonString, options);
  }

  static equals(
    a: StoreKey | PlainMessage<StoreKey> | undefined,
    b: StoreKey | PlainMessage<StoreKey> | undefined,
  ): boolean {
    return proto3.util.equals(StoreKey, a, b);
  }
}

/**
 * @generated from message keyval.StoreInput
 */
export class StoreInput extends Message<StoreInput> {
  /**
   * @generated from oneof keyval.StoreInput.value
   */
  value:
    | {
        /**
         * @generated from field: string raw_string = 2;
         */
        value: string;
        case: "rawString";
      }
    | {
        /**
         * @generated from field: bytes image = 3;
         */
        value: Uint8Array;
        case: "image";
      }
    | {
        /**
         * @generated from field: bytes audio = 4;
         */
        value: Uint8Array;
        case: "audio";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StoreInput>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "keyval.StoreInput";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "raw_string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
    { no: 3, name: "image", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "value" },
    { no: 4, name: "audio", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreInput {
    return new StoreInput().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreInput {
    return new StoreInput().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreInput {
    return new StoreInput().fromJsonString(jsonString, options);
  }

  static equals(
    a: StoreInput | PlainMessage<StoreInput> | undefined,
    b: StoreInput | PlainMessage<StoreInput> | undefined,
  ): boolean {
    return proto3.util.equals(StoreInput, a, b);
  }
}

/**
 * A single entry for a store containing embedding key and its associated metadata values.
 *
 * @generated from message keyval.DbStoreEntry
 */
export class DbStoreEntry extends Message<DbStoreEntry> {
  /**
   * @generated from field: keyval.StoreKey key = 1;
   */
  key?: StoreKey;

  /**
   * @generated from field: keyval.StoreValue value = 2;
   */
  value?: StoreValue;

  constructor(data?: PartialMessage<DbStoreEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "keyval.DbStoreEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: StoreKey },
    { no: 2, name: "value", kind: "message", T: StoreValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DbStoreEntry {
    return new DbStoreEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DbStoreEntry {
    return new DbStoreEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DbStoreEntry {
    return new DbStoreEntry().fromJsonString(jsonString, options);
  }

  static equals(
    a: DbStoreEntry | PlainMessage<DbStoreEntry> | undefined,
    b: DbStoreEntry | PlainMessage<DbStoreEntry> | undefined,
  ): boolean {
    return proto3.util.equals(DbStoreEntry, a, b);
  }
}

/**
 * A single entry for a store containing raw key and its associated metadata values.
 *
 * @generated from message keyval.AiStoreEntry
 */
export class AiStoreEntry extends Message<AiStoreEntry> {
  /**
   * @generated from field: keyval.StoreInput key = 1;
   */
  key?: StoreInput;

  /**
   * @generated from field: keyval.StoreValue value = 2;
   */
  value?: StoreValue;

  constructor(data?: PartialMessage<AiStoreEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "keyval.AiStoreEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: StoreInput },
    { no: 2, name: "value", kind: "message", T: StoreValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AiStoreEntry {
    return new AiStoreEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AiStoreEntry {
    return new AiStoreEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AiStoreEntry {
    return new AiStoreEntry().fromJsonString(jsonString, options);
  }

  static equals(
    a: AiStoreEntry | PlainMessage<AiStoreEntry> | undefined,
    b: AiStoreEntry | PlainMessage<AiStoreEntry> | undefined,
  ): boolean {
    return proto3.util.equals(AiStoreEntry, a, b);
  }
}

/**
 * @generated from message keyval.StoreValue
 */
export class StoreValue extends Message<StoreValue> {
  /**
   * @generated from field: map<string, metadata.MetadataValue> value = 1;
   */
  value: { [key: string]: MetadataValue } = {};

  constructor(data?: PartialMessage<StoreValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "keyval.StoreValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "message", T: MetadataValue },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreValue {
    return new StoreValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreValue {
    return new StoreValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreValue {
    return new StoreValue().fromJsonString(jsonString, options);
  }

  static equals(
    a: StoreValue | PlainMessage<StoreValue> | undefined,
    b: StoreValue | PlainMessage<StoreValue> | undefined,
  ): boolean {
    return proto3.util.equals(StoreValue, a, b);
  }
}
