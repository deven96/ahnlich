// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file db/query.proto (package db.query, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { NonLinearAlgorithm, NonLinearIndex } from "../algorithm/nonlinear_pb.js";
import { DbStoreEntry, StoreKey } from "../keyval_pb.js";
import { PredicateCondition } from "../predicate_pb.js";
import { Algorithm } from "../algorithm/algorithm_pb.js";

/**
 * Creates a new store in the database with the specified dimension, predicates, and non-linear indices.
 * If `error_if_exists` is set to true, it will return an error if the store already exists.
 *
 * @generated from message db.query.CreateStore
 */
export class CreateStore extends Message<CreateStore> {
  /**
   * The name of the store.
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * The dimension of the data within the store.
   *
   * @generated from field: uint32 dimension = 2;
   */
  dimension = 0;

  /**
   * Predicates used for querying.
   *
   * @generated from field: repeated string create_predicates = 3;
   */
  createPredicates: string[] = [];

  /**
   * Non-linear algorithms for indexing.
   *
   * @generated from field: repeated algorithm.nonlinear.NonLinearIndex non_linear_indices = 4;
   */
  nonLinearIndices: NonLinearIndex[] = [];

  /**
   * Flag indicating whether to error if store already exists.
   *
   * @generated from field: bool error_if_exists = 5;
   */
  errorIfExists = false;

  constructor(data?: PartialMessage<CreateStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.CreateStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dimension", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    {
      no: 3,
      name: "create_predicates",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      repeated: true,
    },
    { no: 4, name: "non_linear_indices", kind: "message", T: NonLinearIndex, repeated: true },
    { no: 5, name: "error_if_exists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateStore {
    return new CreateStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateStore {
    return new CreateStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateStore {
    return new CreateStore().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateStore | PlainMessage<CreateStore> | undefined,
    b: CreateStore | PlainMessage<CreateStore> | undefined,
  ): boolean {
    return proto3.util.equals(CreateStore, a, b);
  }
}

/**
 * Retrieves values from the store based on provided keys.
 *
 * @generated from message db.query.GetKey
 */
export class GetKey extends Message<GetKey> {
  /**
   * The name of the store.
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * The keys to retrieve from the store.
   *
   * @generated from field: repeated keyval.StoreKey keys = 2;
   */
  keys: StoreKey[] = [];

  constructor(data?: PartialMessage<GetKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.GetKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "keys", kind: "message", T: StoreKey, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKey {
    return new GetKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKey {
    return new GetKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKey {
    return new GetKey().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetKey | PlainMessage<GetKey> | undefined,
    b: GetKey | PlainMessage<GetKey> | undefined,
  ): boolean {
    return proto3.util.equals(GetKey, a, b);
  }
}

/**
 * Retrieves values from the store based on predicates. Validation checks if the predicate is enabled.
 *
 * @generated from message db.query.GetPred
 */
export class GetPred extends Message<GetPred> {
  /**
   * The name of the store.
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * The condition for the predicate query.
   *
   * @generated from field: predicates.PredicateCondition condition = 2;
   */
  condition?: PredicateCondition;

  constructor(data?: PartialMessage<GetPred>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.GetPred";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "condition", kind: "message", T: PredicateCondition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPred {
    return new GetPred().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPred {
    return new GetPred().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPred {
    return new GetPred().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetPred | PlainMessage<GetPred> | undefined,
    b: GetPred | PlainMessage<GetPred> | undefined,
  ): boolean {
    return proto3.util.equals(GetPred, a, b);
  }
}

/**
 * Retrieves the `n` most similar items to the input vector from the store, using the specified algorithm.
 * Validation checks that the dimensions of the input vector match the store's dimensions.
 * `n` could be less than originally specified.
 *
 * @generated from message db.query.GetSimN
 */
export class GetSimN extends Message<GetSimN> {
  /**
   * The name of the store.
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * The input vector for similarity comparison.
   *
   * @generated from field: keyval.StoreKey search_input = 2;
   */
  searchInput?: StoreKey;

  /**
   * The number of closest matches to return.
   *
   * @generated from field: uint64 closest_n = 3;
   */
  closestN = protoInt64.zero;

  /**
   * The algorithm to use for similarity computation.
   *
   * @generated from field: algorithm.algorithms.Algorithm algorithm = 4;
   */
  algorithm = Algorithm.EuclideanDistance;

  /**
   * The predicate condition to apply.
   *
   * @generated from field: predicates.PredicateCondition condition = 5;
   */
  condition?: PredicateCondition;

  constructor(data?: PartialMessage<GetSimN>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.GetSimN";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "search_input", kind: "message", T: StoreKey },
    { no: 3, name: "closest_n", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "algorithm", kind: "enum", T: proto3.getEnumType(Algorithm) },
    { no: 5, name: "condition", kind: "message", T: PredicateCondition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSimN {
    return new GetSimN().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSimN {
    return new GetSimN().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSimN {
    return new GetSimN().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetSimN | PlainMessage<GetSimN> | undefined,
    b: GetSimN | PlainMessage<GetSimN> | undefined,
  ): boolean {
    return proto3.util.equals(GetSimN, a, b);
  }
}

/**
 * Creates an index in the store based on the provided predicates.
 * This operation is idempotent: it will only add new predicates, not remove existing ones.
 *
 * @generated from message db.query.CreatePredIndex
 */
export class CreatePredIndex extends Message<CreatePredIndex> {
  /**
   * The name of the store.
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * The predicates to create indexes for.
   *
   * @generated from field: repeated string predicates = 2;
   */
  predicates: string[] = [];

  constructor(data?: PartialMessage<CreatePredIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.CreatePredIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "predicates", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreatePredIndex {
    return new CreatePredIndex().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreatePredIndex {
    return new CreatePredIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreatePredIndex {
    return new CreatePredIndex().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreatePredIndex | PlainMessage<CreatePredIndex> | undefined,
    b: CreatePredIndex | PlainMessage<CreatePredIndex> | undefined,
  ): boolean {
    return proto3.util.equals(CreatePredIndex, a, b);
  }
}

/**
 * Creates an index for non-linear algorithms in the store, if it does not already exist.
 * This operation is idempotent: it will only add new non-linear indices, not remove existing ones.
 *
 * @generated from message db.query.CreateNonLinearAlgorithmIndex
 */
export class CreateNonLinearAlgorithmIndex extends Message<CreateNonLinearAlgorithmIndex> {
  /**
   * The name of the store.
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * Non-linear algorithms to create indices for.
   *
   * @generated from field: repeated algorithm.nonlinear.NonLinearIndex non_linear_indices = 2;
   */
  nonLinearIndices: NonLinearIndex[] = [];

  constructor(data?: PartialMessage<CreateNonLinearAlgorithmIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.CreateNonLinearAlgorithmIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "non_linear_indices", kind: "message", T: NonLinearIndex, repeated: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): CreateNonLinearAlgorithmIndex {
    return new CreateNonLinearAlgorithmIndex().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): CreateNonLinearAlgorithmIndex {
    return new CreateNonLinearAlgorithmIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): CreateNonLinearAlgorithmIndex {
    return new CreateNonLinearAlgorithmIndex().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateNonLinearAlgorithmIndex | PlainMessage<CreateNonLinearAlgorithmIndex> | undefined,
    b: CreateNonLinearAlgorithmIndex | PlainMessage<CreateNonLinearAlgorithmIndex> | undefined,
  ): boolean {
    return proto3.util.equals(CreateNonLinearAlgorithmIndex, a, b);
  }
}

/**
 * Drops the specified predicates from the store.
 * If `error_if_not_exists` is true, an error is returned if the predicate does not exist.
 *
 * @generated from message db.query.DropPredIndex
 */
export class DropPredIndex extends Message<DropPredIndex> {
  /**
   * The name of the store.
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * The predicates to drop.
   *
   * @generated from field: repeated string predicates = 2;
   */
  predicates: string[] = [];

  /**
   * Flag indicating whether to error if predicate does not exist.
   *
   * @generated from field: bool error_if_not_exists = 3;
   */
  errorIfNotExists = false;

  constructor(data?: PartialMessage<DropPredIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.DropPredIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "predicates", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "error_if_not_exists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DropPredIndex {
    return new DropPredIndex().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DropPredIndex {
    return new DropPredIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DropPredIndex {
    return new DropPredIndex().fromJsonString(jsonString, options);
  }

  static equals(
    a: DropPredIndex | PlainMessage<DropPredIndex> | undefined,
    b: DropPredIndex | PlainMessage<DropPredIndex> | undefined,
  ): boolean {
    return proto3.util.equals(DropPredIndex, a, b);
  }
}

/**
 * Drops the specified non-linear indices from the store.
 * If `error_if_not_exists` is true, an error is returned if the non-linear index does not exist.
 *
 * @generated from message db.query.DropNonLinearAlgorithmIndex
 */
export class DropNonLinearAlgorithmIndex extends Message<DropNonLinearAlgorithmIndex> {
  /**
   * The name of the store.
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * Non-linear indices to drop.
   *
   * @generated from field: repeated algorithm.nonlinear.NonLinearAlgorithm non_linear_indices = 2;
   */
  nonLinearIndices: NonLinearAlgorithm[] = [];

  /**
   * Flag indicating whether to error if index does not exist.
   *
   * @generated from field: bool error_if_not_exists = 3;
   */
  errorIfNotExists = false;

  constructor(data?: PartialMessage<DropNonLinearAlgorithmIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.DropNonLinearAlgorithmIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 2,
      name: "non_linear_indices",
      kind: "enum",
      T: proto3.getEnumType(NonLinearAlgorithm),
      repeated: true,
    },
    { no: 3, name: "error_if_not_exists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): DropNonLinearAlgorithmIndex {
    return new DropNonLinearAlgorithmIndex().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): DropNonLinearAlgorithmIndex {
    return new DropNonLinearAlgorithmIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): DropNonLinearAlgorithmIndex {
    return new DropNonLinearAlgorithmIndex().fromJsonString(jsonString, options);
  }

  static equals(
    a: DropNonLinearAlgorithmIndex | PlainMessage<DropNonLinearAlgorithmIndex> | undefined,
    b: DropNonLinearAlgorithmIndex | PlainMessage<DropNonLinearAlgorithmIndex> | undefined,
  ): boolean {
    return proto3.util.equals(DropNonLinearAlgorithmIndex, a, b);
  }
}

/**
 * Deletes the specified keys from the store and returns the number of deleted keys.
 * It will also update the indices in a non-blocking manner.
 *
 * @generated from message db.query.DelKey
 */
export class DelKey extends Message<DelKey> {
  /**
   * The name of the store.
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * The keys to delete from the store.
   *
   * @generated from field: repeated keyval.StoreKey keys = 2;
   */
  keys: StoreKey[] = [];

  constructor(data?: PartialMessage<DelKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.DelKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "keys", kind: "message", T: StoreKey, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DelKey {
    return new DelKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DelKey {
    return new DelKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DelKey {
    return new DelKey().fromJsonString(jsonString, options);
  }

  static equals(
    a: DelKey | PlainMessage<DelKey> | undefined,
    b: DelKey | PlainMessage<DelKey> | undefined,
  ): boolean {
    return proto3.util.equals(DelKey, a, b);
  }
}

/**
 * Deletes values from the store based on the provided predicate condition.
 * It will also update the indices in a non-blocking manner.
 *
 * @generated from message db.query.DelPred
 */
export class DelPred extends Message<DelPred> {
  /**
   * The name of the store.
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * The condition for the predicate deletion.
   *
   * @generated from field: predicates.PredicateCondition condition = 2;
   */
  condition?: PredicateCondition;

  constructor(data?: PartialMessage<DelPred>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.DelPred";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "condition", kind: "message", T: PredicateCondition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DelPred {
    return new DelPred().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DelPred {
    return new DelPred().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DelPred {
    return new DelPred().fromJsonString(jsonString, options);
  }

  static equals(
    a: DelPred | PlainMessage<DelPred> | undefined,
    b: DelPred | PlainMessage<DelPred> | undefined,
  ): boolean {
    return proto3.util.equals(DelPred, a, b);
  }
}

/**
 * Drops a store and deletes all its data and associated indices.
 * If `error_if_not_exists` is true, it will return an error if the store does not exist.
 *
 * @generated from message db.query.DropStore
 */
export class DropStore extends Message<DropStore> {
  /**
   * The name of the store.
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * Flag indicating whether to error if store does not exist.
   *
   * @generated from field: bool error_if_not_exists = 2;
   */
  errorIfNotExists = false;

  constructor(data?: PartialMessage<DropStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.DropStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "error_if_not_exists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DropStore {
    return new DropStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DropStore {
    return new DropStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DropStore {
    return new DropStore().fromJsonString(jsonString, options);
  }

  static equals(
    a: DropStore | PlainMessage<DropStore> | undefined,
    b: DropStore | PlainMessage<DropStore> | undefined,
  ): boolean {
    return proto3.util.equals(DropStore, a, b);
  }
}

/**
 * A request to get server information such as host, port, and version.
 *
 * @generated from message db.query.InfoServer
 */
export class InfoServer extends Message<InfoServer> {
  constructor(data?: PartialMessage<InfoServer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.InfoServer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InfoServer {
    return new InfoServer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InfoServer {
    return new InfoServer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InfoServer {
    return new InfoServer().fromJsonString(jsonString, options);
  }

  static equals(
    a: InfoServer | PlainMessage<InfoServer> | undefined,
    b: InfoServer | PlainMessage<InfoServer> | undefined,
  ): boolean {
    return proto3.util.equals(InfoServer, a, b);
  }
}

/**
 * A request to list all the stores on the server, along with their size or length.
 *
 * @generated from message db.query.ListStores
 */
export class ListStores extends Message<ListStores> {
  constructor(data?: PartialMessage<ListStores>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.ListStores";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListStores {
    return new ListStores().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListStores {
    return new ListStores().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListStores {
    return new ListStores().fromJsonString(jsonString, options);
  }

  static equals(
    a: ListStores | PlainMessage<ListStores> | undefined,
    b: ListStores | PlainMessage<ListStores> | undefined,
  ): boolean {
    return proto3.util.equals(ListStores, a, b);
  }
}

/**
 * A request to list all the clients currently connected to the server.
 *
 * @generated from message db.query.ListClients
 */
export class ListClients extends Message<ListClients> {
  constructor(data?: PartialMessage<ListClients>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.ListClients";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClients {
    return new ListClients().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClients {
    return new ListClients().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClients {
    return new ListClients().fromJsonString(jsonString, options);
  }

  static equals(
    a: ListClients | PlainMessage<ListClients> | undefined,
    b: ListClients | PlainMessage<ListClients> | undefined,
  ): boolean {
    return proto3.util.equals(ListClients, a, b);
  }
}

/**
 * A simple ping request to check if the server is reachable.
 *
 * @generated from message db.query.Ping
 */
export class Ping extends Message<Ping> {
  constructor(data?: PartialMessage<Ping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.Ping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ping {
    return new Ping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ping {
    return new Ping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ping {
    return new Ping().fromJsonString(jsonString, options);
  }

  static equals(
    a: Ping | PlainMessage<Ping> | undefined,
    b: Ping | PlainMessage<Ping> | undefined,
  ): boolean {
    return proto3.util.equals(Ping, a, b);
  }
}

/**
 * A request to set multiple key-value entries in the store.
 * Validation is done for each vector before updating the store.
 *
 * @generated from message db.query.Set
 */
export class Set extends Message<Set> {
  /**
   * The name of the store.
   *
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * The key-value entries to set in the store.
   *
   * @generated from field: repeated keyval.DbStoreEntry inputs = 2;
   */
  inputs: DbStoreEntry[] = [];

  constructor(data?: PartialMessage<Set>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "db.query.Set";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "inputs", kind: "message", T: DbStoreEntry, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Set {
    return new Set().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Set {
    return new Set().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Set {
    return new Set().fromJsonString(jsonString, options);
  }

  static equals(
    a: Set | PlainMessage<Set> | undefined,
    b: Set | PlainMessage<Set> | undefined,
  ): boolean {
    return proto3.util.equals(Set, a, b);
  }
}
