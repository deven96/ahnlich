# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: ai/query.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import Dict, List, Optional

import betterproto

from ... import keyval as __keyval__
from ... import metadata as __metadata__
from ... import predicates as __predicates__
from ...algorithm import algorithms as __algorithm_algorithms__
from ...algorithm import nonlinear as __algorithm_nonlinear__
from .. import execution_provider as _execution_provider__
from .. import models as _models__
from .. import preprocess as _preprocess__


@dataclass(eq=False, repr=False)
class CreateStore(betterproto.Message):
    store: str = betterproto.string_field(1)
    """
    Creates a new store with the following details:
     - store name
     - AI query and index models (String or Images are currently supported. It's worth noting that queries/insertions must match the model's supported type)
     - list of predicates for indexing
     - optional non-linear algorithm indices for advanced searching
     - store behavior settings, like error handling and storing original data
    """

    query_model: "_models__.AiModel" = betterproto.enum_field(2)
    index_model: "_models__.AiModel" = betterproto.enum_field(3)
    predicates: List[str] = betterproto.string_field(4)
    non_linear_indices: List["__algorithm_nonlinear__.NonLinearAlgorithm"] = (
        betterproto.enum_field(5)
    )
    error_if_exists: bool = betterproto.bool_field(6)
    store_original: bool = betterproto.bool_field(7)


@dataclass(eq=False, repr=False)
class GetPred(betterproto.Message):
    store: str = betterproto.string_field(1)
    """
    Fetches values from the store that match the specified predicates
     Validation checks if the predicates are enabled
    """

    condition: "__predicates__.PredicateCondition" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class GetSimN(betterproto.Message):
    store: str = betterproto.string_field(1)
    """
    Retrieves the top N similar entries from the store based on a given search input and algorithm
    """

    search_input: "__keyval__.StoreInput" = betterproto.message_field(2)
    condition: Optional["__predicates__.PredicateCondition"] = (
        betterproto.message_field(3, optional=True)
    )
    closest_n: int = betterproto.uint32_field(4)
    algorithm: "__algorithm_algorithms__.Algorithm" = betterproto.enum_field(5)
    preprocess_action: "_preprocess__.PreprocessAction" = betterproto.enum_field(6)
    execution_provider: Optional["_execution_provider__.ExecutionProvider"] = (
        betterproto.enum_field(7, optional=True)
    )


@dataclass(eq=False, repr=False)
class CreatePredIndex(betterproto.Message):
    store: str = betterproto.string_field(1)
    """
    Creates predicate indexes for a store. Adds new predicates if they don’t already exist
    """

    predicates: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class CreateNonLinearAlgorithmIndex(betterproto.Message):
    store: str = betterproto.string_field(1)
    """
    Creates non-linear algorithm indices for the store if they don't already exist
    """

    non_linear_indices: List["__algorithm_nonlinear__.NonLinearAlgorithm"] = (
        betterproto.enum_field(2)
    )


@dataclass(eq=False, repr=False)
class DropPredIndex(betterproto.Message):
    store: str = betterproto.string_field(1)
    """
    Drops a predicate index for the store
     Throws an error if the predicate index doesn’t exist (controlled by `error_if_not_exists`)
    """

    predicates: List[str] = betterproto.string_field(2)
    error_if_not_exists: bool = betterproto.bool_field(3)


@dataclass(eq=False, repr=False)
class DropNonLinearAlgorithmIndex(betterproto.Message):
    store: str = betterproto.string_field(1)
    """
    Drops non-linear algorithm indices from the store
     Similar to dropping predicate indices, does not remove existing data
    """

    non_linear_indices: List["__algorithm_nonlinear__.NonLinearAlgorithm"] = (
        betterproto.enum_field(2)
    )
    error_if_not_exists: bool = betterproto.bool_field(3)


@dataclass(eq=False, repr=False)
class DelKey(betterproto.Message):
    store: str = betterproto.string_field(1)
    """
    Deletes a key-value pair from the store, matching the given key
     Updates indices non-blocking after deletion
    """

    key: "__keyval__.StoreInput" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class DropStore(betterproto.Message):
    store: str = betterproto.string_field(1)
    """
    Deletes the entire store and removes all associated data
     Destroys the store, and updates indices accordingly
    """

    error_if_not_exists: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class GetKey(betterproto.Message):
    store: str = betterproto.string_field(1)
    """
    Fetches specific input(image or string) from a store. This only works if, store_original is set to true
    """

    keys: List["__keyval__.StoreInput"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class InfoServer(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ListClients(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ListStores(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class PurgeStores(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class Ping(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class Set(betterproto.Message):
    store: str = betterproto.string_field(1)
    """
    Sets a list of entries in the store
     Each entry corresponds to a key-value pair and is validated before insertion
    """

    inputs: List["StoreEntry"] = betterproto.message_field(2)
    preprocess_action: "_preprocess__.PreprocessAction" = betterproto.enum_field(3)
    execution_provider: Optional["_execution_provider__.ExecutionProvider"] = (
        betterproto.enum_field(4, optional=True)
    )


@dataclass(eq=False, repr=False)
class StoreEntry(betterproto.Message):
    key: "__keyval__.StoreInput" = betterproto.message_field(1)
    """A single entry in the store"""

    value: Dict[str, "__metadata__.MetadataValue"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
