"use strict";(self.webpackChunkahnlich_web=self.webpackChunkahnlich_web||[]).push([[5197],{28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>l});var t=r(96540);const i={},o=t.createContext(i);function s(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:n},e.children)}},60525:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"client-libraries/go/request-ai/create-store","title":"Create Store","description":"Description","source":"@site/docs/client-libraries/go/request-ai/create-store.md","sourceDirName":"client-libraries/go/request-ai","slug":"/client-libraries/go/request-ai/create-store","permalink":"/docs/client-libraries/go/request-ai/create-store","draft":false,"unlisted":false,"editUrl":"https://github.com/deven96/ahnlich/tree/main/web/ahnlich-web/docs/client-libraries/go/request-ai/create-store.md","tags":[],"version":"current","frontMatter":{"title":"Create Store"},"sidebar":"docsSidebar","previous":{"title":"List Stores","permalink":"/docs/client-libraries/go/request-ai/list-stores"},"next":{"title":"Set","permalink":"/docs/client-libraries/go/request-ai/set"}}');var i=r(74848),o=r(28453);const s={title:"Create Store"},l="Create Store",c={},d=[{value:"Description",id:"description",level:2},{value:"Use cases:",id:"use-cases",level:2},{value:"Source Code Example",id:"source-code-example",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{Details:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"create-store",children:"Create Store"})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"CreateStore"})," is a ",(0,i.jsx)(n.strong,{children:"provisioning request"})," used to define a new AI-backed store within the Ahnlich AI proxy. Unlike the raw DB ",(0,i.jsx)(n.code,{children:"CreateStore"}),", this AI-specific request requires model selection for ",(0,i.jsx)(n.strong,{children:"both indexing"})," and ",(0,i.jsx)(n.strong,{children:"querying"}),". These models determine how raw inputs (e.g., text, images) are embedded and how queries against the store are interpreted.\nKey concepts:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"IndexModel"}),": the embedding model used to transform stored data into vector form."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"QueryModel"}),": the embedding model used to transform incoming queries into vector form before comparison."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Store Name"}),": a unique identifier for the logical collection of embeddings."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This design allows developers to separate how data is stored vs. how queries are expressed. In most cases, the same model is chosen for both roles (as in the example), but they can differ if needed for domain-specific optimization."}),"\n",(0,i.jsx)(n.h2,{id:"use-cases",children:"Use cases:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Creating a dedicated store for text embeddings using a general-purpose model."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Initializing multiple stores with different models for experimentation."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Supporting hybrid workflows where one model indexes the data and another interprets queries."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"source-code-example",children:"Source Code Example"}),"\n",(0,i.jsxs)(r,{children:[(0,i.jsx)("summary",{children:"Click to expand source code"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\n\nimport (\n    "context"\n    "fmt"\n    "log"\n    "time"\n\n\n    "google.golang.org/grpc"\n    "google.golang.org/grpc/credentials/insecure"\n\n\n    aiquery "github.com/deven96/ahnlich/sdk/ahnlich-client-go/grpc/ai/query"\n    aimodel "github.com/deven96/ahnlich/sdk/ahnlich-client-go/grpc/ai/models"\n    aisvc "github.com/deven96/ahnlich/sdk/ahnlich-client-go/grpc/services/ai_service"\n)\n\n\nconst AIAddr = "127.0.0.1:1370"\n\n\n// ExampleAIClient holds the gRPC connection and AI client.\ntype ExampleAIClient struct {\n    conn   *grpc.ClientConn\n    client aisvc.AIServiceClient\n    ctx    context.Context\n}\n\n\n// NewAIClient connects to the AI server and returns a client.\nfunc NewAIClient(ctx context.Context) (*ExampleAIClient, error) {\n    conn, err := grpc.DialContext(ctx, AIAddr, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())\n    if err != nil {\n        return nil, fmt.Errorf("failed to dial AI server %q: %w", AIAddr, err)\n    }\n    client := aisvc.NewAIServiceClient(conn)\n    return &ExampleAIClient{conn: conn, client: client, ctx: ctx}, nil\n}\n\n\n// Close closes the gRPC connection.\nfunc (c *ExampleAIClient) Close() error {\n    return c.conn.Close()\n}\n\n\n// ---- CreateStore Example ----\n// Create a new store for AI operations.\nfunc (c *ExampleAIClient) exampleCreateStoreAI() error {\n    _, err := c.client.CreateStore(c.ctx, &aiquery.CreateStore{\n        Store:            "ai_store",\n        QueryModel:       aimodel.AIModel_ALL_MINI_LM_L6_V2,\n        IndexModel:       aimodel.AIModel_ALL_MINI_LM_L6_V2,\n        Predicates:       []string{},  // Optional: metadata fields to index for filtering\n        NonLinearIndices: []int32{},   // Optional: non-linear algorithms for faster search\n        ErrorIfExists:    true,         // Return error if store already exists\n        StoreOriginal:    true,         // Store original input (needed for key deletion)\n    })\n    if err != nil {\n        return err\n    }\n    fmt.Println(" AI Store created: ai_store01")\n    return nil\n}\n\n\n// ---- MAIN ----\nfunc main() {\n    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n    defer cancel()\n\n\n    client, err := NewAIClient(ctx)\n    if err != nil {\n        log.Fatalf("Failed to create AI client: %v", err)\n    }\n    defer client.Close()\n\n\n    if err := client.exampleCreateStoreAI(); err != nil {\n        log.Fatalf("CreateStore failed: %v", err)\n    }\n}\n\n'})})]}),"\n",(0,i.jsx)(n.p,{children:"Behavior"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["On success, the AI proxy registers a new AI-backed store configured with the provided ",(0,i.jsx)(n.code,{children:"IndexModel"})," and ",(0,i.jsx)(n.code,{children:"QueryModel"})," (the models determine how raw inputs are converted to embeddings for indexing and querying)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"QueryModel"})," and ",(0,i.jsx)(n.code,{children:"IndexModel"})," fields use the ",(0,i.jsx)(n.code,{children:"aimodel"})," enum values supplied in the request; the proxy interprets those enums according to its supported model set."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Errors indicate the operation did not complete (for example, validation failure, naming conflict, or server-side error). The exact failure modes and error payloads are determined by the AI proxy implementation."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);