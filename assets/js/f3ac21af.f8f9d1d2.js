"use strict";(self.webpackChunkahnlich_web=self.webpackChunkahnlich_web||[]).push([[7896],{19239:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"client-libraries/rust/request-ai/drop-non-linear-algx","title":"Drop Non-Linear Algorithm Index","description":"Removes a non-linear algorithm index from a vector store in the AI service. This operation is useful when the index is no longer needed, when changing algorithm parameters, or when rebuilding the index for updated embedding datasets. Removing unused indexes helps maintain storage efficiency and avoids unnecessary overhead during similarity searches.","source":"@site/docs/client-libraries/rust/request-ai/drop-non-linear-algx.md","sourceDirName":"client-libraries/rust/request-ai","slug":"/client-libraries/rust/request-ai/drop-non-linear-algx","permalink":"/docs/client-libraries/rust/request-ai/drop-non-linear-algx","draft":false,"unlisted":false,"editUrl":"https://github.com/deven96/ahnlich/tree/main/web/ahnlich-web/docs/client-libraries/rust/request-ai/drop-non-linear-algx.md","tags":[],"version":"current","frontMatter":{"title":"Drop Non-Linear Algorithm Index"},"sidebar":"docsSidebar","previous":{"title":"Create Non-Linear Algorithm Index","permalink":"/docs/client-libraries/rust/request-ai/create-non-linear-algx"},"next":{"title":"New","permalink":"/docs/client-libraries/rust/request-ai/new"}}');var t=r(74848),s=r(28453);const o={title:"Drop Non-Linear Algorithm Index"},a="Drop Non-Linear Algorithm Index",l={},d=[{value:"Source Code Example",id:"source-code-example",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Returns",id:"returns",level:2},{value:"Behavior (explains the code, brief)",id:"behavior-explains-the-code-brief",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"drop-non-linear-algorithm-index",children:"Drop Non-Linear Algorithm Index"})}),"\n",(0,t.jsxs)(n.p,{children:["Removes a ",(0,t.jsx)(n.strong,{children:"non-linear algorithm index"})," from a vector store in the ",(0,t.jsx)(n.strong,{children:"AI service"}),". This operation is useful when the index is no longer needed, when changing algorithm parameters, or when rebuilding the index for updated embedding datasets. Removing unused indexes helps maintain storage efficiency and avoids unnecessary overhead during similarity searches."]}),"\n",(0,t.jsx)(n.h2,{id:"source-code-example",children:"Source Code Example"}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:"Click to expand"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use ahnlich_client_rs::ai::AiClient;\nuse ahnlich_types::ai::query::DropNonLinearAlgorithmIndex;\nuse ahnlich_types::algorithm::nonlinear::NonLinearAlgorithm;\nuse tokio;\n\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Connect to AI server\n    let client = AiClient::new("http://127.0.0.1:1370".to_string()).await?;\n\n\n    // Set parameters for dropping the non-linear index\n    let params = DropNonLinearAlgorithmIndex {\n        store: "MyStore".to_string(),\n        non_linear_indices: vec![NonLinearAlgorithm::KdTree as i32],\n        error_if_not_exists: true, // do not error if the index doesn\'t exist\n    };\n\n\n    // Execute drop request\n    let result = client\n        .drop_non_linear_algorithm_index(params, None)\n        .await?;\n  \n    println!("Dropped non-linear indices: {:?}", result);\n\n\n    Ok(())\n}\n'})})]}),"\n",(0,t.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"params: DropNonLinearAlgorithmIndex"})," \u2014 Specifies the store and the non-linear index to remove."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"returns",children:"Returns"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Ok(Del)"})," \u2014 Confirmation that the non-linear algorithm index was successfully deleted."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Err(AhnlichError)"})," \u2014 Returned if the index does not exist, the store is unavailable, or the operation fails."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"behavior-explains-the-code-brief",children:"Behavior (explains the code, brief)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Wraps the ",(0,t.jsx)(n.code,{children:"DropNonLinearAlgorithmIndex"})," parameters in a ",(0,t.jsx)(n.code,{children:"tonic::Request"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Attaches optional tracing metadata."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Sends the request to the AI service via RPC."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Awaits the response and extracts the result."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Returns a ",(0,t.jsx)(n.code,{children:"Del"})," object indicating successful deletion of the index."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var i=r(96540);const t={},s=i.createContext(t);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);