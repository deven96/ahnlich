"use strict";(self.webpackChunkahnlich_web=self.webpackChunkahnlich_web||[]).push([[8202],{28453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>o});var r=n(96540);const i={},s=r.createContext(i);function l(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(s.Provider,{value:t},e.children)}},72917:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"client-libraries/rust/request-db/delete-key","title":"Delete Key","description":"Removes a single key and its associated vector and metadata from a store. This operation permanently deletes the entry, ensuring it is no longer retrievable in similarity searches or direct lookups. Use this to manage lifecycle of individual records without affecting the rest of the store.","source":"@site/docs/client-libraries/rust/request-db/delete-key.md","sourceDirName":"client-libraries/rust/request-db","slug":"/client-libraries/rust/request-db/delete-key","permalink":"/docs/client-libraries/rust/request-db/delete-key","draft":false,"unlisted":false,"editUrl":"https://github.com/deven96/ahnlich/tree/main/web/ahnlich-web/docs/client-libraries/rust/request-db/delete-key.md","tags":[],"version":"current","frontMatter":{"title":"Delete Key"},"sidebar":"docsSidebar","previous":{"title":"Drop Predicate Index","permalink":"/docs/client-libraries/rust/request-db/drop-predicate-index"},"next":{"title":"Drop Store","permalink":"/docs/client-libraries/rust/request-db/drop-store"}}');var i=n(74848),s=n(28453);const l={title:"Delete Key"},o="Delete Key",d={},a=[{value:"Source Code Example",id:"source-code-example",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Returns",id:"returns",level:2},{value:"Behavior",id:"behavior",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"delete-key",children:"Delete Key"})}),"\n",(0,i.jsx)(t.p,{children:"Removes a single key and its associated vector and metadata from a store. This operation permanently deletes the entry, ensuring it is no longer retrievable in similarity searches or direct lookups. Use this to manage lifecycle of individual records without affecting the rest of the store."}),"\n",(0,i.jsx)(t.h2,{id:"source-code-example",children:"Source Code Example"}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Click to expand"}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ahnlich_client_rs::db::DbClient;\nuse ahnlich_types::db::query::DelKey;\nuse ahnlich_types::keyval::StoreKey;\nuse tokio;\n\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let addr = "http://127.0.0.1:1369"; // adjust if your server runs elsewhere\n    let client = DbClient::new(addr.to_string()).await?;\n\n\n    // Delete a specific key from store "Main" (dimension must match)\n    let del_key_params = DelKey {\n        store: "Main".to_string(),\n        keys: vec![StoreKey {\n            key: vec![1.0, 1.1, 1.2], // \u2705 matches dimension=3\n        }],\n    };\n\n\n    match client.del_key(del_key_params, None).await {\n        Ok(result) => println!("Deleted count: {:?}", result.deleted_count),\n        Err(e) => eprintln!("Error: {:?}", e),\n    }\n\n\n    Ok(())\n}\n'})})]}),"\n",(0,i.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"params: DelKey"})," \u2014 Identifies the store and the specific key to delete."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"tracing_id: Option<String>"})," \u2014 Optional trace context for observability."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"returns",children:"Returns"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"Del"})," \u2014 Confirmation that the key was successfully removed."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"AhnlichError"})," \u2014 If the key or store does not exist."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"behavior",children:"Behavior"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Builds a gRPC request targeting the key specified."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Adds optional trace metadata for distributed tracing."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Executes the ",(0,i.jsx)(t.code,{children:"del_key"})," RPC, removing the vector and metadata tied to the key."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);