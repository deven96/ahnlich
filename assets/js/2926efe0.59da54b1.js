"use strict";(self.webpackChunkahnlich_web=self.webpackChunkahnlich_web||[]).push([[2230],{28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var i=r(96540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}},40975:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"client-libraries/rust/request-db/get-simn","title":"Get Sim N","description":"The GetSimN request retrieves the top-N most similar vectors to a given query vector from a specified store. This is the core similarity search operation in Ahnlich DB, allowing you to find nearest neighbors by vector distance.","source":"@site/docs/client-libraries/rust/request-db/get-simn.md","sourceDirName":"client-libraries/rust/request-db","slug":"/client-libraries/rust/request-db/get-simn","permalink":"/docs/client-libraries/rust/request-db/get-simn","draft":false,"unlisted":false,"editUrl":"https://github.com/deven96/ahnlich/tree/main/web/ahnlich-web/docs/client-libraries/rust/request-db/get-simn.md","tags":[],"version":"current","frontMatter":{"title":"Get Sim N"},"sidebar":"docsSidebar","previous":{"title":"Set","permalink":"/docs/client-libraries/rust/request-db/set"},"next":{"title":"Get Key","permalink":"/docs/client-libraries/rust/request-db/get-key"}}');var s=r(74848),t=r(28453);const l={title:"Get Sim N"},o="Get Sim N",c={},d=[{value:"Source Code Example",id:"source-code-example",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Returns",id:"returns",level:2},{value:"Behavior",id:"behavior",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components},{Details:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"get-sim-n",children:"Get Sim N"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"GetSimN"})," request retrieves the ",(0,s.jsx)(n.strong,{children:"top-N most similar vectors"})," to a given query vector from a specified store. This is the core similarity search operation in Ahnlich DB, allowing you to find nearest neighbors by vector distance."]}),"\n",(0,s.jsx)(n.h2,{id:"source-code-example",children:"Source Code Example"}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"Click to expand"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use ahnlich_client_rs::db::DbClient;\nuse ahnlich_types::{\n    algorithm::algorithms::Algorithm,\n    db::query::GetSimN,\n    keyval::StoreKey,\n};\nuse tokio;\n\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // connect to server\n    let addr = "http://127.0.0.1:1369"; // adjust to your server address\n    let db_client = DbClient::new(addr.to_string()).await?;\n\n\n    // prepare parameters\n    let params = GetSimN {\n        store: "Main".to_string(),\n        search_input: Some(StoreKey { key: vec![1.0, 2.0, 3.0] }),\n        closest_n: 2,\n        algorithm: Algorithm::EuclideanDistance as i32,\n        condition: None,\n    };\n\n\n    // call get_sim_n\n    let response = db_client.get_sim_n(params, None).await?;\n    println!("Response: {:?}", response);\n\n\n    Ok(())\n}\n\n'})})]}),"\n",(0,s.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"params: GetSimN"})," \u2013 Defines the similarity search query. This includes:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"store"})," \u2013 The name of the target store."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"vector"})," \u2013 The query vector (",(0,s.jsx)(n.code,{children:"Vec<f32>"}),") used to compute similarity."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"n"})," \u2013 The number of nearest neighbors to return."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"predicate"})," (optional) \u2013 A filter expression applied to metadata before similarity is calculated."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"tracing_id: Option<String>"})," \u2013 Optional identifier for distributed tracing."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"returns",children:"Returns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Ok(GetSimNResult)"})," \u2013 A structured result containing:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"matches"})," \u2013 A ranked list of vectors with associated similarity scores, keys, and metadata."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"count"})," \u2013 The number of results returned (up to ",(0,s.jsx)(n.code,{children:"n"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Err(AhnlichError)"})," \u2013 Possible error cases:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Store not found."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Query vector does not match store dimensionality."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Invalid or malformed predicate filter."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Transport or server-side errors."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"behavior",children:"Behavior"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The search is ",(0,s.jsx)(n.strong,{children:"approximate or exact"})," depending on the index configuration of the store."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Returned results are sorted in descending order of similarity (most similar first)."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If a predicate filter is provided, only vectors satisfying the filter are considered for similarity ranking."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Results include both the vector key and any metadata if available."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);