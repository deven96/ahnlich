// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Predicate {
    #[prost(oneof = "predicate::Kind", tags = "1, 2, 3, 4")]
    pub kind: ::core::option::Option<predicate::Kind>,
}
/// Nested message and enum types in `Predicate`.
pub mod predicate {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Equals(super::Equals),
        #[prost(message, tag = "2")]
        NotEquals(super::NotEquals),
        #[prost(message, tag = "3")]
        In(super::In),
        #[prost(message, tag = "4")]
        NotIn(super::NotIn),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Equals {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<super::metadata::MetadataValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotEquals {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<super::metadata::MetadataValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct In {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<super::metadata::MetadataValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotIn {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<super::metadata::MetadataValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredicateCondition {
    #[prost(oneof = "predicate_condition::Kind", tags = "1, 2, 3")]
    pub kind: ::core::option::Option<predicate_condition::Kind>,
}
/// Nested message and enum types in `PredicateCondition`.
pub mod predicate_condition {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Value(super::Predicate),
        #[prost(message, tag = "2")]
        And(::prost::alloc::boxed::Box<super::AndCondition>),
        #[prost(message, tag = "3")]
        Or(::prost::alloc::boxed::Box<super::OrCondition>),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndCondition {
    #[prost(message, optional, boxed, tag = "1")]
    pub left: ::core::option::Option<::prost::alloc::boxed::Box<PredicateCondition>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub right: ::core::option::Option<::prost::alloc::boxed::Box<PredicateCondition>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrCondition {
    #[prost(message, optional, boxed, tag = "1")]
    pub left: ::core::option::Option<::prost::alloc::boxed::Box<PredicateCondition>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub right: ::core::option::Option<::prost::alloc::boxed::Box<PredicateCondition>>,
}
