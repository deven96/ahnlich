---
title: Use Cases
sidebar_position: 30
---

# Use Cases

### 1. Semantic Search
Semantic search goes beyond keyword matching it finds items that are **conceptually similar** to a query. With **Ahnlich DB**, embeddings generated by NLP models (e.g., sentence-transformers, OpenAI, BERT) can be stored and queried.

**Example:**
 A news website wants to allow readers to search for articles by meaning, not just keywords.
- **Query:** “climate change effects on agriculture”

- **Stored vectors:** embeddings of articles from the archive.

- **Ahnlich DB** retrieves the most similar vectors using **cosine similarity**, filtering out irrelevant categories (e.g., `topic != sports`).

```go
GETSIMN 5 WITH [0.42, -0.13, 0.76, ...] USING cosinesimilarity 
IN news_store WHERE (topic != sports)
```

This returns the top 5 most semantically similar articles, even if the exact keywords differ.


### 2. Recommendation Engines
Recommendation systems depend on finding similar users or items. By storing user embeddings and item embeddings, **Ahnlich DB** can power **real-time recommendations**.

**Example:**
An e-commerce platform wants to recommend products to a user based on their browsing history.

- **User embedding:** **[0.24, 0.15, 0.93, ...]** (from their profile + past behavior).

- **Product embeddings:** vectors representing catalog items.

- **Query:** Find the 10 most similar products to the user’s embedding.

```go
get_sim_n(
    store="product_store",
    search_input=[0.24, 0.15, 0.93, ...],
    closest_n=10,
    algorithm=CosineSimilarity,
    condition=Predicate::NotEquals {
        key="status",
        value="out_of_stock",
    }
)
``` 

This returns **personalized recommendations**, excluding unavailable items.


### 3. Clustering & Exploration
Clustering groups together vectors that are close in high-dimensional space. **Ahnlich DB** makes this possible by serving as a **backbone for unsupervised learning workflows**.

**Example:**
A research lab stores embeddings of thousands of genomic sequences. To discover patterns:

- Query vectors representing sequences with certain traits.

- Run similarity searches to group them into clusters.

- Use metadata filters (`species = human`) to narrow analysis.

This allows scientists to explore relationships between data points without explicit labels.


### 4. Filtering with Context
**Ahnlich DB** allows developers to combine **vector similarity search** with **predicate-based filtering** to return results that are both semantically relevant and contextually constrained.

**Example:**
A video platform wants to recommend “similar” videos but only those uploaded in the last 12 months.

```go
find top-8 similar videos
GETSIMN 8 WITH [0.89, -0.33, 0.55, ...] USING euclideandistance IN video_store;

filter results by upload_date
GETPRED (upload_date > "2024-09-01") IN video_store;
```

In this workflow, GETSIMN identifies the most similar vectors, while `GETPRED` applies metadata conditions. By chaining them together, applications ensure that retrieved results are not only “similar” but also satisfy real-world constraints such as **time windows, categories, or user-specific rules**.


### 5. Cross-Domain Retrieval
Since embeddings can represent any modality—text, images, audio—**Ahnlich DB** supports **multi-modal retrieval**.

Example:
A fashion company wants customers to upload a **photo of an outfit** and find similar products in their catalog.

- Image  converted into an embedding.

- Query against the vector database (`fashion_store`).

- Metadata filter ensures only items in stock are suggested.

```go
GETSIMN 3 WITH [0.31, 0.88, 0.64, ...] USING cosinesimilarity 
IN fashion_store WHERE (availability = "in_stock")

This enables image-to-product search, a powerful e-commerce feature.
```


## Setup & Configuration (**Ahnlich DB**)
This section explains how to install, configure, and run **Ahnlich DB**. The database can run standalone and is available as prebuilt binaries and Docker images for multiple platforms.

